<h1> Описание счетчиков JaCoCo</h1>

<h3>INSTRUCTION:</h3>
Наименьшая единица отсчета JaCoCo - это инструкции одиночного байтового кода Java. Покрытие инструкций предоставляет
информацию об объеме кода, который был выполнен или пропущен. Эта метрика полностью независима от исходного
форматирования и всегда доступна, даже при отсутствии отладочной информации в файлах классов.
<h3>LINE:</h3>
Основываясь на состоянии покрытия каждой ветки, JaCoCo также вычисляет покрытую и пропущенную сложность для каждого
метода. Пропущенная сложность снова указывает на то, что количество тестовых случаев отсутствует, чтобы полностью
покрыть модуль.
<h3>BRANCH:</h3>
Определяет покрытие ветвей для оперторов if и switch. Этот счетчик подсчитывает общее количество таких ветвей в методе и
определяет количество выполненных или пропущенных ветвей.
<h3>COMPLEXITY:</h3>
Просчитывает различные пути, которые могут в формулах, с помощью метода. Таким образом, значение сложности может служить
индикатором количества примеров модульного тестирования, которые полностью охватывают определенную часть программного
обеспечения.

<h3> Цикломатическая Сложность</h3>
JaCoCo также вычисляет цикломатическую сложность для каждого неабстрактного метода и суммирует
сложность для классов, пакетов и групп. Согласно его определению McCabe1996 цикломатическая сложность-это минимальное
количество путей, которые могут в (линейной) комбинации генерировать все возможные пути с помощью метода. Таким образом,
значение сложности может служить показателем количества единичных тестовых случаев, чтобы полностью охватить
определенную часть программного обеспечения. Показатели сложности всегда можно вычислить, даже при отсутствии отладочной
информации в файлах класса.

Формальное определение цикломатической сложности v(G) основано на представлении графа потока управления метода в виде
ориентированного графа:

<h3>v(G) = E - N + 2</h3>

Где E-число ребер и N-число узлов. JaCoCo вычисляет цикломатическую сложность метода с помощью следующего эквивалентного
уравнения, основанного на количестве ветвей (B) и количестве точек принятия решений (D):

<h3>v(G) = B - D + 1</h3>

Основываясь на состоянии покрытия каждой ветви, JaCoCo также вычисляет покрытую и пропущенную сложность для каждого
метода. Пропущенная сложность снова является показателем количества тестовых случаев, отсутствующих для полного покрытия
модуля. Обратите внимание, что, поскольку JaCoCo не рассматривает обработку исключений в качестве ветвей, блоки
try/catch также не увеличивают сложность.


